{"ast":null,"code":"import React, { memo, useMemo, useRef, useEffect } from \"react\";\nimport Typed from \"typed.js\";\nexport const ReactTyped = memo(({\n  style,\n  className,\n  typedRef,\n  parseRef: transformRef,\n  stopped,\n  children,\n  startWhenVisible,\n  ...typedOptions\n}) => {\n  const rootElement = useRef(null);\n  const shouldUpdateArgs = useMemo(() => [...Object.values(typedOptions).filter(v => typeof v === \"boolean\" || typeof v === \"number\" || typeof v === \"string\"), typedOptions.strings?.join(\",\")], [typedOptions]);\n  useEffect(() => {\n    const element = transformRef && transformRef(rootElement) || rootElement.current;\n    const typed = new Typed(element, {\n      ...typedOptions\n    });\n    if (stopped || startWhenVisible) {\n      typed?.stop();\n    }\n    if (startWhenVisible) {\n      const observer = new IntersectionObserver(([entry]) => {\n        if (entry.isIntersecting) {\n          typed?.start();\n          observer.disconnect();\n        }\n      });\n      observer.observe(element);\n    }\n    if (typedRef && typed) {\n      typedRef(typed);\n    }\n    return () => {\n      typed.destroy();\n    };\n  }, shouldUpdateArgs);\n  const child = !children ? React.createElement(\"span\", {\n    style: style,\n    ref: rootElement\n  }) : React.cloneElement(children, {\n    ref: rootElement\n  });\n  return React.createElement(\"span\", {\n    style: style,\n    className: className,\n    \"data-testid\": \"react-typed\"\n  }, child);\n});\nexport { Typed };","map":{"version":3,"names":["React","memo","useMemo","useRef","useEffect","Typed","ReactTyped","style","className","typedRef","parseRef","transformRef","stopped","children","startWhenVisible","typedOptions","rootElement","shouldUpdateArgs","Object","values","filter","v","strings","join","element","current","typed","stop","observer","IntersectionObserver","entry","isIntersecting","start","disconnect","observe","destroy","child","createElement","ref","cloneElement"],"sources":["C:\\Users\\nafee\\Documents\\Projects\\E-Terra\\Frontend\\node_modules\\react-typed\\src\\index.tsx"],"sourcesContent":["import React, { memo, useMemo, useRef, useEffect } from \"react\";\r\nimport Typed from \"typed.js\";\r\nexport interface ReactTypedProps {\r\n  stopped?: boolean;\r\n  /**\r\n   * if true will be initialized in stopped state\r\n   * @default false\r\n   * */\r\n  startWhenVisible?: boolean;\r\n  /**\r\n   * Styles for the created element in case children is not provided\r\n   * */\r\n  style?: React.CSSProperties;\r\n  /**\r\n   * class name for the created element in case children is not provided\r\n   * */\r\n  className?: string;\r\n  /**\r\n   * In some custom component dom element is not in the ref.current property.\r\n   * ie an Input by antd the element is in input property ( ref.current.input )\r\n   * you can use this function to get the element from the ref\r\n   * @default (ref)=>ref.current\r\n   * */\r\n  parseRef?: (ref: React.RefObject<any>) => HTMLElement;\r\n  /**\r\n   * Returns the typed instance\r\n   * */\r\n  typedRef?: (typed: Typed) => void;\r\n  /**\r\n   * strings to be typed\r\n   * @default [\r\n    'These are the default values...',\r\n    'You know what you should do?',\r\n    'Use your own!',\r\n    'Have a great day!',\r\n  ]\r\n   * */\r\n  children?: React.ReactElement;\r\n  strings?: string[];\r\n  /**\r\n   * ID or instance of HTML element of element containing string children\r\n   * @default null\r\n   */\r\n  stringsElement?: string | Element;\r\n  /**\r\n   * type speed in milliseconds\r\n   * @default 0\r\n   */\r\n  typeSpeed?: number;\r\n  /**\r\n   * time before typing starts in milliseconds\r\n   * @default 0\r\n   */\r\n  startDelay?: number;\r\n  /**\r\n   * backspacing speed in milliseconds\r\n   * @default 0\r\n   */\r\n  backSpeed?: number;\r\n  /**\r\n   * only backspace what doesn't match the previous string\r\n   * @default true\r\n   */\r\n  smartBackspace?: boolean;\r\n  /**\r\n   * shuffle the strings\r\n   * @default true\r\n   */\r\n  shuffle?: boolean;\r\n  /**\r\n   * time before backspacing in milliseconds\r\n   * @default 700\r\n   */\r\n  backDelay?: number;\r\n  /**\r\n   * Fade out instead of backspace\r\n   * @default false\r\n   */\r\n  fadeOut?: boolean;\r\n  /**\r\n   * css class for fade animation\r\n   * @default typed-fade-out\r\n   */\r\n  fadeOutClass?: string;\r\n  /**\r\n   * Fade out delay in milliseconds\r\n   * @default 500\r\n   */\r\n  fadeOutDelay?: number;\r\n  /**\r\n   * loop strings\r\n   * @default false\r\n   */\r\n  loop?: boolean;\r\n  /**\r\n   * amount of loops\r\n   * @default Infinity\r\n   */\r\n  loopCount?: number;\r\n  /**\r\n   * show cursor\r\n   * @default true\r\n   */\r\n  showCursor?: boolean;\r\n  /**\r\n   * character for cursor\r\n   * @default |\r\n   */\r\n  cursorChar?: string;\r\n  /**\r\n   * insert CSS for cursor and fadeOut into HTML\r\n   * @default true\r\n   */\r\n  autoInsertCss?: boolean;\r\n  /**\r\n   * attribute for typing Ex: input placeholder, value, or just HTML text\r\n   * @default null\r\n   */\r\n  attr?: string;\r\n  /**\r\n   * bind to focus and blur if el is text input\r\n   * @default false\r\n   */\r\n  bindInputFocusEvents?: boolean;\r\n  /**\r\n   * 'html' or 'null' for plaintext\r\n   * @default html\r\n   */\r\n  contentType?: string;\r\n  /**\r\n   * Before it begins typing the first string\r\n   */\r\n  onBegin?: (self: Typed) => number;\r\n  /**\r\n   * All typing is complete\r\n   */\r\n  onComplete?(self: Typed): void;\r\n  /**\r\n   * Before each string is typed\r\n   */\r\n  preStringTyped?(arrayPos: number, self: Typed): void;\r\n  /**\r\n   * After each string is typed\r\n   */\r\n  onStringTyped?(arrayPos: number, self: Typed): void;\r\n  /**\r\n   * During looping, after last string is typed\r\n   */\r\n  onLastStringBackspaced?(self: Typed): void;\r\n  /**\r\n   * Typing has been stopped\r\n   */\r\n  onTypingPaused?(arrayPos: number, self: Typed): void;\r\n  /**\r\n   * Typing has been started after being stopped\r\n   */\r\n  onTypingResumed?(arrayPos: number, self: Typed): void;\r\n  /**\r\n   * After reset\r\n   */\r\n  onReset?(self: Typed): void;\r\n  /**\r\n   * After stop\r\n   */\r\n  onStop?(arrayPos: number, self: Typed): void;\r\n  /**\r\n   * After start\r\n   */\r\n  onStart?(arrayPos: number, self: Typed): void;\r\n  /**\r\n   * After destroy\r\n   */\r\n  onDestroy?(self: Typed): void;\r\n}\r\n\r\nexport const ReactTyped: React.FC<ReactTypedProps> = memo(\r\n  ({\r\n    style,\r\n    className,\r\n    typedRef,\r\n    parseRef,\r\n    stopped,\r\n    children,\r\n    startWhenVisible,\r\n    ...typedOptions\r\n  }) => {\r\n    const rootElement = useRef<any>(null);\r\n    const shouldUpdateArgs = useMemo(\r\n      () => [\r\n        ...Object.values(typedOptions).filter(\r\n          (v) =>\r\n            typeof v === \"boolean\" ||\r\n            typeof v === \"number\" ||\r\n            typeof v === \"string\"\r\n        ),\r\n        typedOptions.strings?.join(\",\"),\r\n      ],\r\n      [typedOptions]\r\n    );\r\n    useEffect(() => {\r\n      const element =\r\n        (parseRef && parseRef(rootElement)) || rootElement.current;\r\n      const typed = new Typed(element, { ...typedOptions });\r\n\r\n      if (stopped || startWhenVisible) {\r\n        typed?.stop();\r\n      }\r\n\r\n      if (startWhenVisible) {\r\n        const observer = new IntersectionObserver(([entry]) => {\r\n          if (entry.isIntersecting) {\r\n            typed?.start();\r\n            observer.disconnect();\r\n          }\r\n        });\r\n        observer.observe(element);\r\n      }\r\n\r\n      if (typedRef && typed) {\r\n        typedRef(typed);\r\n      }\r\n      return () => {\r\n        typed.destroy();\r\n      };\r\n    }, shouldUpdateArgs);\r\n\r\n    const child = !children ? (\r\n      <span style={style} className={className} ref={rootElement} />\r\n    ) : (\r\n      React.cloneElement(children, {\r\n        ref: rootElement,\r\n      })\r\n    );\r\n    return child;\r\n  }\r\n);\r\n\r\nexport { Typed };\r\n"],"mappings":"AAAA,OAAOA,KAAK,IAAIC,IAAI,EAAEC,OAAO,EAAEC,MAAM,EAAEC,SAAS,QAAQ,OAAO;AAC/D,OAAOC,KAAK,MAAM,UAAU;AAkL5B,OAAO,MAAMC,UAAU,GAA8BL,IAAI,CACvD,CAAC;EACCM,KAAK;EACLC,SAAS;EACTC,QAAQ;EACRC,QAAQ,EAAEC,YAAY;EACtBC,OAAO;EACPC,QAAQ;EACRC,gBAAgB;EAChB,GAAGC;AAAY,CAChB,KAAI;EACH,MAAMC,WAAW,GAAGb,MAAM,CAAM,IAAI,CAAC;EACrC,MAAMc,gBAAgB,GAAGf,OAAO,CAC9B,MAAM,CACJ,GAAGgB,MAAM,CAACC,MAAM,CAACJ,YAAY,CAAC,CAACK,MAAM,CAClCC,CAAC,IACA,OAAOA,CAAC,KAAK,SAAS,IACtB,OAAOA,CAAC,KAAK,QAAQ,IACrB,OAAOA,CAAC,KAAK,QAAQ,CACxB,EACDN,YAAY,CAACO,OAAO,EAAEC,IAAI,CAAC,GAAG,CAAC,CAChC,EACD,CAACR,YAAY,CAAC,CACf;EACDX,SAAS,CAAC,MAAK;IACb,MAAMoB,OAAO,GACVb,YAAY,IAAIA,YAAY,CAACK,WAAW,CAAC,IAAKA,WAAW,CAACS,OAAO;IACpE,MAAMC,KAAK,GAAG,IAAIrB,KAAK,CAACmB,OAAO,EAAE;MAAE,GAAGT;IAAY,CAAE,CAAC;IAErD,IAAIH,OAAO,IAAIE,gBAAgB,EAAE;MAC/BY,KAAK,EAAEC,IAAI,EAAE;IACf;IAEA,IAAIb,gBAAgB,EAAE;MACpB,MAAMc,QAAQ,GAAG,IAAIC,oBAAoB,CAAC,CAAC,CAACC,KAAK,CAAC,KAAI;QACpD,IAAIA,KAAK,CAACC,cAAc,EAAE;UACxBL,KAAK,EAAEM,KAAK,EAAE;UACdJ,QAAQ,CAACK,UAAU,EAAE;QACvB;MACF,CAAC,CAAC;MACFL,QAAQ,CAACM,OAAO,CAACV,OAAO,CAAC;IAC3B;IAEA,IAAIf,QAAQ,IAAIiB,KAAK,EAAE;MACrBjB,QAAQ,CAACiB,KAAK,CAAC;IACjB;IACA,OAAO,MAAK;MACVA,KAAK,CAACS,OAAO,EAAE;IACjB,CAAC;EACH,CAAC,EAAElB,gBAAgB,CAAC;EAEpB,MAAMmB,KAAK,GAAG,CAACvB,QAAQ,GACrBb,KAAA,CAAAqC,aAAA;IAAM9B,KAAK,EAAEA,KAAK;IAAE+B,GAAG,EAAEtB;EAAW,EAAI,GAExChB,KAAK,CAACuC,YAAY,CAAC1B,QAAQ,EAAE;IAC3ByB,GAAG,EAAEtB;GACN,CACF;EACD,OACEhB,KAAA,CAAAqC,aAAA;IAAM9B,KAAK,EAAEA,KAAK;IAAEC,SAAS,EAAEA,SAAS;IAAA,eAAc;EAAa,GAChE4B,KAAK,CACD;AAEX,CAAC,CACF;AAED,SAAS/B,KAAK"},"metadata":{},"sourceType":"module","externalDependencies":[]}